//+------------------------------------------------------------------+
//|                                              YanTE_SMC_EA.mq5    |
//|                   Smart Money Concept Framework                  |
//|         Modified: Profit-Based Risk (Equity Scaling)             |
//|         Updated: 1:1 Profit Lock instead of Break-Even           |
//+------------------------------------------------------------------+
#property strict

#include <Trade/Trade.mqh>
CTrade Trade;

//+------------------------------------------------------------------+
//| Inputs                                                           |
//+------------------------------------------------------------------+
input double   InpStartBalance = 10000.0;   // Your Starting Capital
input double   InpProfitRisk   = 2.0;       // Risk (%) of Accumulated Profit
input double   InpMinRiskLot   = 0.01;      // Minimum lot if no profit exists
input int      InpTP_Ratio     = 3;         // RR Target (1:3)
input int      InpBE_Ratio     = 2;         // Trigger Ratio (At 1:2 move SL to 1:1)
input ENUM_TIMEFRAMES InpTF    = PERIOD_M15;

//+------------------------------------------------------------------+
//| Globals                                                          |
//+------------------------------------------------------------------+
double min_lot, max_lot, lot_step;

//+------------------------------------------------------------------+
//| Init                                                             |
//+------------------------------------------------------------------+
int OnInit()
{
   min_lot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   max_lot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

   if(InpStartBalance <= 0) {
      Print("Error: Start Balance must be greater than 0");
      return INIT_FAILED;
   }

   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Tick                                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   SecureProfit();

   if(!HasOpenPosition())
      CheckForEntry();
}

//+------------------------------------------------------------------+
//| Check if symbol already has position                             |
//+------------------------------------------------------------------+
bool HasOpenPosition()
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol)
            return true;
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| Risk-based lot calculation (Risking % of Accumulated Profit)     |
//+------------------------------------------------------------------+
double CalculateLot(double slPoints)
{
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double accumulatedProfit = currentEquity - InpStartBalance;
   double riskMoney = 0;

   if(accumulatedProfit > 0) 
   {
      riskMoney = accumulatedProfit * (InpProfitRisk / 100.0);
      Print("Current Profit: ", accumulatedProfit, " | Risking: ", riskMoney);
   } 
   else 
   {
      Print("No accumulated profit. Using minimum risk.");
      return InpMinRiskLot;
   }

   double tickValue  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize   = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);

   if(slPoints <= 0 || tickValue <= 0) return InpMinRiskLot;

   double valuePerPoint = tickValue / tickSize;
   double lot = riskMoney / (slPoints * valuePerPoint);

   lot = MathMax(min_lot, MathMin(lot, max_lot));
   lot = NormalizeDouble(lot / lot_step, 0) * lot_step;

   return lot;
}

//+------------------------------------------------------------------+
//| Execute trade                                                    |
//+------------------------------------------------------------------+
void ExecuteTrade(bool buy, double slPrice)
{
   double entry = buy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                      : SymbolInfoDouble(_Symbol, SYMBOL_BID);

   double riskPoints = MathAbs(entry - slPrice) / _Point;
   if(riskPoints <= 0) return;

   double lot = CalculateLot(riskPoints);

   double tp = buy
      ? entry + (riskPoints * InpTP_Ratio * _Point)
      : entry - (riskPoints * InpTP_Ratio * _Point);

   Trade.SetDeviationInPoints(20);

   bool result = buy
      ? Trade.Buy(lot, _Symbol, entry, slPrice, tp)
      : Trade.Sell(lot, _Symbol, entry, slPrice, tp);

   if(result)
      Print("Trade opened | Lot: ", lot, " | Profit Risking: ", InpProfitRisk, "%");
   else
      Print("Trade failed: ", Trade.ResultComment());
}

//+------------------------------------------------------------------+
//| 1:1 Profit Lock Logic                                            |
//+------------------------------------------------------------------+
void SecureProfit()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(!PositionSelectByTicket(ticket))
         continue;

      if(PositionGetString(POSITION_SYMBOL) != _Symbol)
         continue;

      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double curPrice  = PositionGetDouble(POSITION_PRICE_CURRENT);
      double sl        = PositionGetDouble(POSITION_SL);
      double tp        = PositionGetDouble(POSITION_TP);

      // We need to calculate original risk from the distance of TP or manually
      // Since TP is entry + (risk * TP_Ratio), risk = (TP - Entry) / TP_Ratio
      double risk = MathAbs(tp - openPrice) / InpTP_Ratio;
      if(risk <= 0) continue;

      ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

      // BUY POSITION
      if(type == POSITION_TYPE_BUY)
      {
         // If price hits 1:2 (entry + 2*risk) and SL is still below 1:1 profit (entry + 1*risk)
         if(curPrice >= openPrice + (risk * InpBE_Ratio) && sl < (openPrice + risk - _Point))
         {
            double newSL = openPrice + risk;
            Trade.PositionModify(ticket, newSL, tp);
            Print("BUY: Price reached 1:", InpBE_Ratio, ". SL secured at 1:1 profit.");
         }
      }

      // SELL POSITION
      if(type == POSITION_TYPE_SELL)
      {
         // If price hits 1:2 (entry - 2*risk) and SL is still above 1:1 profit (entry - 1*risk)
         if(curPrice <= openPrice - (risk * InpBE_Ratio) && (sl > (openPrice - risk + _Point) || sl == 0))
         {
            double newSL = openPrice - risk;
            Trade.PositionModify(ticket, newSL, tp);
            Print("SELL: Price reached 1:", InpBE_Ratio, ". SL secured at 1:1 profit.");
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Entry logic (BOS / Displacement)                                 |
//+------------------------------------------------------------------+
void CheckForEntry()
{
   double high1 = iHigh(_Symbol, InpTF, 1);
   double low1  = iLow(_Symbol, InpTF, 1);
   double close1 = iClose(_Symbol, InpTF, 1);

   double high2 = iHigh(_Symbol, InpTF, 2);
   double low2  = iLow(_Symbol, InpTF, 2);

   bool bullish = close1 > high2;
   bool bearish = close1 < low2;

   if(bullish)
      ExecuteTrade(true, low1);

   else if(bearish)
      ExecuteTrade(false, high1);
}
